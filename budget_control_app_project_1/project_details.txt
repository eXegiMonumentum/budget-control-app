#Aplikacja do zarządzania budżetem
# Opis projektu:
# Aplikacja do zarządzania budżetem osobistym to narzędzie,
które umożliwia użytkownikowi monitorowanie swoich finansów poprzez dodawanie transakcji,
przypisywanie ich do odpowiednich kategorii, a także generowanie szczegółowych raportów.
Celem aplikacji jest pomoc w analizie wydatków i zarządzaniu finansami, co pozwala na lepsze planowanie budżetu.

# Technologie:
# Backend: Python
# Baza danych: PostgreSQL
# Interfejs użytkownika: Konsola (możliwość rozszerzenia na interfejs webowy w przyszłości)
# Biblioteki: psycopg2 do połączenia z PostgreSQL, matplotlib do prostych wizualizacji danych

# Funkcje aplikacji:

# 1. Rejestracja i logowanie użytkowników: (V)
#  --- Możliwość zakładania konta z hasłem.
#  --- Logowanie do istniejącego konta.
#  --- Ochrona hasła przy użyciu szyfrowania (np. bcrypt).

# 2. Dodawanie transakcji: (V)
#
#  --- Możliwość dodawania przychodów i wydatków.
#  --- Pola: kwota, data, kategoria (np. jedzenie, transport, rozrywka), opcjonalny opis.
#  --- Każda transakcja jest powiązana z kontem użytkownika, który ją dodał.

# 3. Zarządzanie kategoriami:

#  --- Dodawanie, edytowanie i usuwanie kategorii.

# 4. Generowanie raportów:
#
#  --- Raport miesięczny: Wyświetlanie sumy przychodów, sumy wydatków i bilansu netto za dany miesiąc.
#  --- Raport kategorii: Sumaryczne wydatki w podziale na kategorie (np. ile wydano na jedzenie, transport itp.).
#  --- Raport trendów: Wizualizacja trendów wydatków/przychodów na przestrzeni miesięcy -- Wykresy !.

# 5. Analiza wydatków:
#
#  --- Średnie wydatki na kategorię.
#  --- Wykresy przedstawiające wydatki w poszczególnych kategoriach.
#  --- Ostrzeżenia przy przekroczeniu ustalonych budżetów dla kategorii.

# 6. Zarządzanie budżetem:

#  --- Możliwość ustawienia miesięcznego budżetu dla poszczególnych kategorii.
#  --- Powiadomienia (np. w konsoli) o zbliżaniu się do limitu wydatków w danej kategorii.

# 7. Eksport danych:
#
#  ---
#  --- Możliwość wygenerowania raportu w formie tekstowej lub wykresu.


# 8. Historia transakcji:
#
#  --- Przeglądanie historii transakcji, z możliwością filtrowania po dacie, kategorii lub kwocie.





# Kroki realizacji projektu:
# Projekt bazy danych:


# Interfejs użytkownika:

# Zbuduj interaktywny interfejs w konsoli, umożliwiający łatwą nawigację po funkcjach aplikacji.
# Zaimplementuj logikę logowania, rejestracji, dodawania transakcji i generowania raportów.
# Testowanie:
#
# Testuj każdą funkcję oddzielnie, a następnie przeprowadzaj testy integracyjne, aby upewnić się, że wszystkie elementy działają razem.
# Dokumentacja:
#
# Sporządź dokumentację, opisującą jak zainstalować i używać aplikacji.
# Dodaj przykłady użycia oraz wyjaśnienie struktury bazy danych.
# Możliwości rozbudowy:
# Przeniesienie interfejsu z konsoli do prostego interfejsu webowego (np. z Flask).
# Implementacja systemu powiadomień e-mailowych lub SMS.
# Wersja mobilna aplikacji (np. z wykorzystaniem frameworka Kivy).
# Taki projekt pokaże Twoje umiejętności w zakresie programowania w Pythonie, zarządzania bazami danych, a także tworzenia aplikacji, które rozwiązują rzeczywiste problemy.
from logger import logger


## POMYSŁY:
----------------------------!@#!!#@!@#@!@#@!#@!@##!@ tutaj :

###  generowania raportów - wrapper -// z wykorzystanim mojego projektu tekstowego :) ? .

# 3. Zarządzanie kategoriami:
#  --- Dodawanie, edytowanie i usuwanie kategorii.
#  --- Przykładowe kategorie: Jedzenie, Transport, Rozrywka, Rachunki, Inne.
#  --- Możliwość dodawania własnych kategorii przez użytkownika.
# dodawania transakcji przez użytkownika



#ideas:
    #można wykorzystać zapisy wg. daty transakcji i logowanie tych transakcji w plikach tekstowych #projekt python planner!.
    # wykorzystać do tego wrapper.




feat: Dodanie nowej funkcjonalności do kodu (np. nowa funkcja lub komponent).

Przykład: fe
fix: Naprawa błędu.

Przykład: fix: resolve user login issue
docs: Zmiany w dokumentacji (np. README, dokumentacja API).

Przykład: docs: update installation instructions
style: Zmiany, które nie wpływają na znaczenie kodu (np. formatowanie, brakujący średnik, itp.).

Przykład: style: format code to follow PEP8
refactor: Zmiany w kodzie, które nie naprawiają błędów ani nie dodają nowych funkcji (np. zmiana struktury kodu).

Przykład: refactor: optimize user authentication logic
test: Dodanie brakujących testów lub korekta istniejących testów.

Przykład: test: add unit tests for login component
chore: Zmiany w budowaniu narzędzi, skrypty konfiguracyjne, aktualizacje zależności, które nie wpływają na kod produkcyjny.

Przykład: chore: update npm dependencies
perf: Zmiana poprawiająca wydajność.

Przykład: perf: improve database query performance
build: Zmiany, które wpływają na system budowania lub zewnętrzne zależności (np. npm, gradle).

Przykład: build: update webpack configuration
ci: Zmiany dotyczące konfiguracji CI/CD (Continuous Integration/Continuous Deployment).

Przykład: ci: update TravisCI configuration


# może funckja umożliwiająca zmianę waluty ze zł na dolary czy jakośtak.